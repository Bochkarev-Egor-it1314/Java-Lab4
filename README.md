# Java-Lab4

# Отчет по работе: Реализация задач на Java
Бочкарёв Егор ИТ-13,14

## Общее описание
Данный проект представляет собой консольное приложение на Java, которое реализует 7 различных задач:
1. Задание 1. Обобщенная коробка
2. Задание 2. Сравнимое
3. Задание 3. Поиск максимума
4. Задание 4. Функция
5. Задание 5. Фильтр
6. Задание 6. Сокращение
7. Задание 7. Коллекционирование

Программа предлагает пользователю выбрать задачу через меню, затем выполняет соответствующую функцию.

## Структура проекта
- Класс `Main` с вызовом всех задач и пользовательским интерфейсом
- Класс `Box`, который создает "Коробку", в которой может быть любое число и класс исключения `BoxFullException` для попытки положить объект в уже заполненную коробку
- Класс `Car` и его интерфейс `Compare`, который нужен для сравнения 2 данных
- Класс `BoxUtilits` для поиска максимального элемента из множества коробок
- Класс `GenericMethods`, который содержит
    - Метод `mapList` и его интерфейс `Applicator` для преобразования списков
    - Метод `filterList` и его интерфейс `Tester` для фильтрации списков
    - Метод `reduce` и его интерфейс `Combiner` для сокращения списков
    - Метод `collectTo` с интерфейсами `Collector` и `Accumulator` для коллекционирования
- Класс `Helper`, который содержит
    - Метод `workWithBox` для выполнения действий с коробкой
    - Метод `maxOfArray` для вычисления максимума в массиве
    - Метод `hasPositive` для проверки, есть ли в массиве положительные элементы
- Класс `Check` для проверки входных данных

## Детальный анализ методов

### Задание 1.1 (Обобщенная коробка)

**<ins>Задача:</ins>**

Создайте сущность Коробка, которая обладает следующими характеристиками:
+ Может хранить один произвольный объект в один момент времени.
+ Объект можно получить и разместить на хранение в любой момент времени.
+ Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
+ Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
+ Имеет метод проверки на заполненность.
+ Методы класса должны работать с тем типом данных, который был указан во время создания объекта.

Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3. Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран. 

**<ins>Метод решения:</ins>**

Эта задача решается созданием нового класса `Box`. Внутри класса 1 поле: `item` типа `T`, которое хранит содержимое коробки. Класс имеет 2 конструктора: конструктор по умолчанию, который создает пустую коробку, и конструктор с начальным значением, который сразу размещает объект в коробке.

Все методы класса работают с типом данных, который был указан при создании объекта коробки, благодаря использованию обобщенного типа:

`put(T item)` - размещает объект в коробке. Если коробка уже заполнена, выбрасывает исключение

`get()` - извлекает объект из коробки. После извлечения ссылка на объект обнуляется

`isEmpty()` - проверяет, пуста ли коробка

`toString()` - возвращает строковое представление коробки

`T getItem()` - геттер

Класс исключения `BoxFullException` отвечает за вывод ошибки при попытки положить объект в уже заполненную коробку

В `Main` создается коробка. После в нее кладут число (с клавиатуры), затем достают его и обнуляют ссылку на него и выводится состояние коробки после операции (Пустая или заполненная) благодоря методу `workWithBox`, который отвечает за действия с коробкой. Вывод содержимого коробки идет через метод `toString`.

**<ins>Код реализации:</ins>**
```
package ru.Bochkarev.TaskOne;

public class Box<T> {
    private T item;

    // Конструктор: создаёт пустую коробку
    public Box() {
        this.item = null;
    }

    // Конструктор: создаёт коробку с начальным элементом
    public Box(T initial) {
        this.item = initial;
    }

    // Положить объект в коробку. Если коробка не пуста — бросаем исключение.
    public void put(T newItem) throws BoxFullException {
        if (!isEmpty()) {
            throw new BoxFullException("Коробка уже заполнена объектом => " + item);
        }
        this.item = newItem;
    }

    // Взять объект из коробки
    public T get() {
        T temp = this.item;
        this.item = null; // обнуляем ссылку после извлечения
        return temp;
    }

    // Проверка на заполненность
    public boolean isEmpty() {
        return this.item == null;
    }

    // Геттер
    public T getItem() {
        return item;
    }

    // Сеттер
    public void setItem(T item) {
        this.item = item;
    }

    // Возвращение строки
    @Override
    public String toString() {
        if (isEmpty()) {
            return "~Коробка пуста~";
        } else {
            return "Коробка >>> предмет в ней это " + this.item;
        }
    }
}
```

```
package ru.Bochkarev.TaskOne;

// Класс исключения для попытки положить объект в уже заполненную коробку
public class BoxFullException extends Exception {

    public BoxFullException(String message) {
        super(message);
    }

    @Override
    public String toString() {
        return "ru.Bochkarev.TaskOne.BoxFullException: " + getMessage();
    }
}

```

```
// Метод работы с коробкой
    public static void workWithBox(Box<Integer> box) {
        System.out.println("=Действия с коробкой=");
        Integer value = box.get(); // после этого коробка станет пустой
        if (value != null) {
            System.out.println("> Извлечённое значение: " + value);
        } else {
            System.out.println("> Коробка была пустой.");
        }
        System.out.println("> Состояние коробки после извлечения: " + box);
    }
```

```
System.out.println("Задание 1");

                    // Проверка ввода
                    System.out.println("\nПожалуйста, введите целое число 3:");
                    int userItem = 0;
                    while (true) {
                        System.out.print("Введите число: ");
                        try {
                            userItem = scan.nextInt();
                            if (userItem != 3) {
                                System.out.println("Ошибка: требуется ввести число 3. Попробуйте ещё раз.");
                                continue;
                            }
                            break;
                        } catch (InputMismatchException ime) {
                            System.out.println("Неверный ввод: требуется целое число. Попробуйте ещё раз.");
                            scan.next(); // очистка неверного токена
                        }
                    }

                    // Создаём коробку
                    Box<Integer> insideBox = new Box<>();
                    try {
                        insideBox.put(userItem);
                        System.out.println("Внутри коробки: " + insideBox);
                    } catch (BoxFullException e) {
                        System.out.println("Не удалось положить объект: " + e.getMessage());
                    }

                    // Выполнение действий с коробкой
                    Helper.workWithBox(insideBox);
```

**<ins>Вывод на экран:</ins>**

Пожалуйста, введите целое число 3:

Введите число: 3

Внутри коробки: Коробка >>> предмет в ней это 3

=Действия с коробкой=

.> Извлечённое значение: 3

.> Состояние коробки после извлечения: Коробка пуста
***

### Задание 1.3 (Сравнимое)

**<ins>Задача:</ins>**

Создайте ссылочный тип Сравнимое, гарантирующий наличие по данной ссылке метода со следующими характеристиками:
+ Называется “сравнить”
+ Принимает объект.
+ Тип принимаемого объекта может быть изменен без изменения самого Сравнимого.
+ Возвращает целое число. 

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

### Задание 2.2 (Поиск максимума)

**<ins>Задача:</ins>**

Создайте метод, принимающий набор Коробок из задачи 3.1.1 и возвращающий максимальное из их значений в формате double. Принимаемые методом Коробки могут быть параметризованы любыми видами чисел.

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

### Задание 3.1 (Функция)

**<ins>Задача:</ins>**

Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать. Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, где каждое число соответствует длине каждой строки.
2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все отрицательные числа стали положительными, а положительные остались без изменений
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только максимальные значения каждого из исходных массивов 

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

### Задание 3.2 (Фильтр)

**<ins>Задача:</ins>**

Разработайте такой метод, который будет принимать список значений типа T и объект имеющий единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из которого удалены все значения не прошедшие проверку условием. Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все строки имеющие менее трех символов
2. Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные элементы
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только те массивы, в которых нет ни одного положительного элемента 

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

### Задание 3.3 (Сокращение)

**<ins>Задача:</ins>**

Разработайте такой метод, который будет принимать список значений типа T и способ с помощью которого список значений можно свести к одному значению типа T, которое и возвращается из метода.  Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями:  “qwerty”, “asdfg”, “zx”, и сформируйте одну большую строку, которая состоит из всех строк исходного списка.
2. Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного списка.
3. Имеется список, состоящий из списков целых чисел, получите общеe количество элементов во всех списках. Подсказка: решить задачу можно в одно действие или последовательно использовать методы из 3.3.1 и 3.3.3.

Далее необходимо изменить разработанный метод таким образом, чтобы данный метод гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список пуст. 

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

### Задание 3.4 (Сокращение)

**<ins>Задача:</ins>**

Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T. Данный метод будет принимать:
1. Список исходных значений
2. Способ создания результирующей коллекции
3. Способ передачи значений исходного списка в результирующую коллекцию.

Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два подсписка, в одном из которых будут только положительные числа, а в другом только отрицательные.
2. Передайте в метод список со значениями:  “qwerty”, “asdfg”, “zx”, “qw” и верните их разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только одинаковой длины
3. Передайте в метод список со значениями:  “qwerty”, “asdfg”, “qwerty”, “qw” и верните набор такого вида, который не может содержать одинаковые объекты. 

**<ins>Метод решения:</ins>**


**<ins>Код реализации:</ins>**


**<ins>Вывод на экран:</ins>**


***

## Вспомогательные методы

+ `public int readInt(Scanner scanner)`

Что делает:

Читает из Scanner целое число, пока пользователь не введёт корректное значение.

Как работает (пошагово):
- Заходит в бесконечный цикл while (true).
- Печатает приглашение "Введите целое число: ".
- Проверяет scanner.hasNextInt() — есть ли следующий токен, который можно распарсить как int.
- Если true: читает int num = scanner.nextInt(); и возвращает num.
- Иначе: печатает сообщение об ошибке и вызывает scanner.next() — чтобы "съесть" неверный токен (иначе hasNextInt() будет снова false и цикл застрянет).

Примеры:

При вводе 42 вернёт 42; при вводе abc — попросит ввести ещё раз.

Код:
```
public int readInt(Scanner scanner) {
        while (true) {
            System.out.print("Введите целое число: ");
            if (scanner.hasNextInt()) {
                int num = scanner.nextInt();
                return num;
            } else {
                System.out.println("Ошибка: введите целое число!");
                scanner.next(); // очищаем неверный ввод
            }
        }
    }
```
